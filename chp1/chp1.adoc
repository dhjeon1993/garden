# 오브젝트와 의존관계
작성자 <dhjeon1993@gmail.com>
V1.0, 2019-12-06
:toc:
:icons:

## 오브젝트와 의존관계
DAO(Data Access Object)::
DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

자바빈 규약::
* 디폴트 생성자
* 프로퍼티 & getter, setter

## 관심사 분리(Separation of Concerns)  
관심이 같은 로직들은 하나의 객체 또는 관련있는 객체에 모이게 하고 관심이 다른 것은 객체에서 분리하여 서로 영향을 주지 않도록 한다.

### 관심사 분리의 목적
* 객체 내에서 여러가지 요인으로 인한 코드의 변화가 존재할 수 있다.
  ** 접속 DB의 변화
  ** 프로토콜의 변화
  ** 정책의 변화 등...
* 변경이 일어났을 때 관심사 별로 객체를 분리해 놓았다면 필요한 작업을 최소화 하고 변경사항이 다른 객체에 영향이 가지 않게 만들 수 있다.
* 분리와 확장을 고려한 설계가 가능해 진다.

### 관심사 분리의 방법
* 중복 코드의 메소드 추출
* 상속을 통한 확장
** 템플릿 메소드 패턴
** 팩토리 메소드 패턴
* 클래스의 분리 +
=> 변화의 성격이 다른 것들은 다른 클래스로 분리
+
====
.관심사 성격의 변화
  변화의 성격이 다르다는 것은 해당 관심사가 변화하는 이유, 시기, 주기가 다르다는 것이다.
  이렇게 변화의 성격이 다른 관심사들을 분리하여 서로 영향을 주지 않고 변화가 필요한 시기에 독립적으로 변경할 수 있어야 한다.
  성격이 다른 관심사들을 분리해야 서로 코드에 영향을 주지 않는 객체를 만들 수 있다.
====

* 인터페이스의 도입
  
### 관계설정 책임의 분리
#### 관계 설정 책임 분리의 이유
* 독립적으로 확장 가능한 클래스가 될 수 없다.
* 관계 설정 또한 하나의 관심사가 될 수 있다.

#### 관계 설정 책임 분리의 방법
두 개의 오브젝트가 있고 한 오브젝트가 다른 오브젝트의 기능을 사용한다면, 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 셈이다. 따라서 사용되는 오브젝트를 서비스, 사용하는 오브젝트를 클라이언트라고 부를 수 있다.

클라이언트 오브젝트가 관계 설정 관심사의 기능을 분리해 두기에 적절한 곳이다.

클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다. 따라서 클래스가 아니라 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다.

오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.

IMPORTANT: 클래스 사이의 관계과 오브젝트 사이의 관계를 잘 구분할 수 있어야 한다.


.클라이언트의 책임
  관계 설정에 있어서 클라이언트는 런타임 오브젝트 관계를 갖는 구조로 만들어주는 것에 대한 책임이 있다.


## 원칙과 패턴
좋은 구조의 코드를 작성하기 위해 객체지향 기술의 여러가지 이론에 대해 알아보자.

### 객체지향 설계 원칙(SOLID)
객체지향 설계 원칙은 객체지향의 특징을 잘 살릴 수 있는 설계의 특징을 말한다.

오랜 시간 동안 많은 학자와 개발자 사이에서 공감대가 형성된 객체지향 설계에 관한 여러 가지 원리와 원칙을 체계적으로 잘 정리하고, 멋진 이름과 약자도 만들어서 공개된 것이 바로 SOLID라고도 불리는 5가지 객체지향 설계의 원칙이다.

* SRP(The Single Responsibility Principle): +
  단일 책임 원칙
* OCP(The Open Closed Principle): +
  개방 폐쇄 원칙
* LSP(The Liskov Substitution Principle): +
  리스코프 치환 원칙
* ISP(The Interface Segregation Principle): +
  인터페이스 분리 원칙
* DIP(The Dependency Inversion Principle): +
  의존관게 역전 원칙

### 높은 응집도와 낮은 결합도
응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.
불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여 있다.
높은 응집도는 클래스 레벨뿐 아니라, 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.

#### 높은 응집도
응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수 있다.
즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.

#### 낮은 결합도
낮은 결함도는 높은 응집도보다 더 민감한 원칙이다.
책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어 주는 것이다.

.결합도란
'하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도'라고 설명할 수 있다.
낮은 결합도란 결국, 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다.

낮은 결합도의 장점::
  * 변화에 대응하는 속도가 높아진다.
  * 구성이 깔끔해 진다.
  * 확장하기에 매우 편리하다.

#### 전략 패턴
전략 패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다.
전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

전략 패턴의 적용 방법을 보면 클라이언트의 역할이 잘 설명되어 있다.

  컨텍스트를 사용하는 클라이언트는 컨텍스트가 사용할 전략을 컨텍스트의 생성자 등을 통해 제공해주는 게 일반적이다.


## 제어의 역전(IoC: Inversion of Control)
====
팩토리::
  객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 일을 하는 오브젝트를 팩토리(Factory)라고 부른다.
====

일반적인 프로그램의 경우 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조다.

제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다.
제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 생성하고 선택하지 않는다.
모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.

제어의 역전 개념이 적용된 예::
* 서블릿
* 디자인 패턴 중 템플릿 메소드 패턴
* 프레임워크

.프레임워크와 라이브러리의 차이
[NOTE]
====
라이브러리:: 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.
단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.

프레임워크:: 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.
보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.
====

제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
IoC를 애플리케이션 전반에 걸쳐 본격적으로 적용하려면 스프링과 같은 IoC 프레임워크의 도움을 받는 편이 훨씬 유리하다.


## 스프링의 IoC
스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크이다.

### 애플리케이션 컨텍스트와 설정정보
스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

빈 팩토리는 빈을 생성하고 관계를 설정하는  IoC의 기본 기능에 초점을 맞춘 것이고, 애플리케이션 컨텍스트는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 좀 더 부각된다.

애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다.

.설정정보를 만드는 방법
* 어노테이션
* XML 파일
* 추가?

.애플리케이션 컨텍스트를 사용 시 장점
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 용어 정리
====
빈(bean)::
  스프링에서 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트

빈 팩토리(bean factory)::
  스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라 부른다. +
  빈 팩토리는 스프링의 IoC를 담당하는 핵심 컨테이너이다.

애플리케이션 컨텍스트(application context)::
  빈 팩토리를 좀 더 확장한 것이다. +
  IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다. +
  빈을 등록하고 관리하는 기본적인 기능에 더불어 스프링이 제공하는 각종 부가 서비스를 추가 제공한다.

설정정보 / 설정 메타정보(configuration / metadata)::
  스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. +
  IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.

컨테이너(Container) 또는 IoC 컨테이너::
  IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다.
  컨테이너라는 말 자체가 IoC의 개념을 담고 있기 때문에 이름이 긴 애플리케이션 컨텍스트 대신에 스프링 컨테이너라고 부르기도 한다.
====

## 싱글톤 레지스트리와 오브젝트 스코프
스프링의 애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와는 중요한 차이점이 있다.


====
.오브젝트의 동일성과 동등성
* 동일성(identity)
  -- 두 개의 오브젝트가 완전히 동일한 오브젝트인 경우.
* 동등성(equality)
  -- 두 개의 오브젝트가 동일한 정보를 담고 있는 경우.
====

스프링 빈 팩토리의 `getBean()` 을 두 번 호출해서 가져온 오브젝트가 동일하다. 
스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.
이는 `getBean()` 을 호출할 때 마다 매번 새로운 오브젝트를 생성하는 것이 아니라는 것을 알 수 있다.

=> 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리(singleton registry)이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

CAUTION: 여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤
.스프링이 싱글톤으로 빈을 만드는 이유
스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. +
태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버환경에서 사용될 때 그 가치가 있다.
실제로 스프링은 대부분 서버환경에서 사용된다.

서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이다. 

그런데 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다면 요청 한 번에 5개의 오브젝트가 만들어지고 초당 500개의 요청이 들어오면, 초당 2500개의 새로운 오브젝트가 생성된다. 아무리 자바의 오브젝트 생성과 가비지 컬렉션(GC)의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.

그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다. 
서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있다. 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.

서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

=> 서버환경에서는 서비스 싱글톤의 사용이 권장된다.

하지만 디자인 패턴에 소개된 싱글톤 패턴은 사용하기 까다롭고 여러 가지 문제점이 있다.

====
싱글톤 패턴(Singlton Pattern)::
  싱글톤 패턴은 GoF가 소개한 디자인 패턴 중의 하나다. 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다. +
  싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. +
  단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.

.싱글톤 패턴의 구현 방법(java)

[source,java]
....
public class Singleton {
  private Singleton() { // <1>
    ...
  }

  private static Singleton instance; // <2>

  public static Singleton getInstance() { // <3>
    if(Singleton.instance == null) {
      Singleton.instance = new Singleton();
    }

    return Singleton.instance; // <4>
  }
  ...
}
....
<1> 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
<2> 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
<3> 스태틱 팩토리 메소드인 `getInstance()` 를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다.
  생성된 오브젝트는 스태틱 필드에 저장된다. 
  또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
<4> 한번 오브젝트가 만들어지고 난 후에는 `getInstance()` 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

.싱글톤 패턴의 한계
* private 생성자를 가지고 있기 때문에 상속할 수 없다.
* 싱글톤은 테스트하기가 힘들다.
* 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
* 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

====

### 싱글톤 레지스트리
스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다.
하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. -> 싱글톤 레지스트리

.싱글톤 레지스트리의 장점
  스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.

### 싱글톤과 오브젝트 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.
따라서 상태 관리에 주의를 기울여야 한다.
기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다.

싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 않는다.

### 스프링 빈의 스코프
스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위를 빈의 스코프(scope)라고 한다.
스프링의 기본 스코프는 싱글톤이다.

====
.빈 스코프의 종류
singleton::
  하나의 Bean 정의에 대해서 Spring IoC Container 내에 단 하나의 객체만 존재한다.
prototype::
  하나의 Bean 정의에 대해서 다수의 객체가 존재할 수 있다.
request::
  하나의 Bean 정의에 대해서 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재한다. +
  Web-aware Spring ApplicationContext 안에서만 유효하다.
session::
  하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. +
  Web-aware Spring ApplicationContext 안에서만 유효하다.
global session::
  하나의 Bean 정의에 대해서 하나의 global HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. +
  일반적으로 portlet context 안에서 유효하다. +
  Web-aware Spring ApplicationContext 안에서만 유효하다.
====

## 의존관계 주입(DI, Dependency Injection)
스프링의 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다.

### 런타임 의존관계 설정
.의존관계
의존관계에는 방향성이 있다.
두 클래스가 있을 때, 한 클래스가 다른 클래스에 의존하는 경우 의존하는 다른 클래스가 변경되면 해당 클래스도 같이 영향을 받는다. 반대의 경우는 영향을 주지 않는다.

.의존관계 주입의 조건
* 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
  그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
* 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
* 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다.
스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제3의 존재라고 볼 수 있다.

### 의존관계 검색
코드에서 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주입과 비슷하지만, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 의존관계 검색(dependency lookup)이 있다.

의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다.
하지만 의존관계 검색은 코드 안에 스프링 API가 나타난다. 

대개는 의존관계 주입이 적절하지만 일부는 어쩔 수 없이 의존관계 검색을 사용해야 한다.
=> 애플리케이션의 기동 시점...

====
.의존관계 주입과 의존관계 검색의 중요한 차이점
의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다.

반면에 의존관계 주입에서는 주입받는 대상도 반드시 스프링 빈이어야 한다.
====

.의존관계 주입의 장점
* 기능 구현의 교환
* 부가기능 추가

### 의존관계 주입 방법
* 수정자 메소드를 이용한 주입
* 일반 메소드를 이용한 주입 (한 번에 여러 파라미터를 받을 수 있다.)

## XML을 이용한 설정
[cols=3]
|===
| 
|자바 코드 설정정보 
|XML 설정정보

|빈 설정파일 
|@Configuration 
|<beans>

|빈의 이름 
|@Bean methodName() 
|<bean id="methodName"

|빈의 클래스
|return new BeanClass();
|class="a.b.c... BeanClass">
|===

### XML을 이용하는 애플리케이션 컨텍스트
XML에서 빈의 의존관계 정보를 이용하는 IoC/DI 작업에는 `GenericXmlApplicationContext` 를 사용한다.
`GenericXmlApplicationContext` 의 생성자 파라미터로 XML 파일의 클래스패스를 지정해주면 된다.

### XML에서의 값 주입
텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 스프링에서는 '값을 주입한다'고 말한다.

스프링의 빈으로 등록될 클래스에 수정자 메소드가 정의되어 있다면 `<property>` 를 사용해 주입할 정보를 지정할 수 있다. 

주입되는 값은 전달되는 스트링 그 자체다.

====
.value 값의 자동 변환
스트링 타입이 아닌 값은 스프링이 프로퍼티의 값을, 수정자 메소드의 파라미터 타입을 참고로 해서 적절한 형태로 변환해준다.
====
